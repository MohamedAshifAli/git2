import os

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt
import scipy.io
from glob import glob

# Function for Butterworth bandpass filter
directory = glob("trainingnew\\training\\*.mat")
# from scipy.signal import find_peaks

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt
import scipy.io
from glob import glob

# Function for Butterworth bandpass filter


# Derivative filter
def derivative_filter(data):
    derivative_pass = np.diff(data, prepend=data[0])
    return derivative_pass

# Squaring function
def squaring(data):
    square_pass = data ** 2
    return square_pass

# Moving average filter
def moving_window_integration(data, sample_rate, window_size=None):
    if window_size is None:
        assert sample_rate is not None, "if window size is None, sampling rate should be given"
        window_size = int(0.08 * int(sample_rate))
    integrated_signal = np.zeros(len(data))
    cumulative_sum = np.cumsum(data)
    integrated_signal[window_size:] = (cumulative_sum[window_size:] - cumulative_sum[:-window_size]) / window_size
    integrated_signal[:window_size] = cumulative_sum[:window_size] / np.arange(1, window_size + 1)
    return integrated_signal
from scipy.signal import butter, filtfilt

# Define Butterworth bandpass filter
def butter_bandpass(lowcut, highcut, fs, order=5):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return b, a

def butter_bandpass_filter(data, lowcut, highcut, fs, order=5):
    b, a = butter_bandpass(lowcut, highcut, fs, order=order)
    y = filtfilt(b, a, data)
    return y

def differentiate(signal):
    return np.diff(signal)

def find_pqrst_waves(directory):
    fs = 1000

def calculate_threshold(signal, threshold_factor=0.5):
        x = np.mean(signal) * threshold_factor
        return x

# def find_peaks(diff_signal, threshold):
#     peaks, _ = scipy.signal.find_peaks(diff_signal[0], height=threshold)
#     return peaks

def find_peaks(diff_signal, threshold):
    all_peaks = []
    for i in range(diff_signal.shape[0]):
        peaks, _ = scipy.signal.find_peaks(diff_signal[i], height=threshold)
        all_peaks.append(peaks)
    return all_peaks

def mark_pqrst(filtered_signal, peaks):
    p_waves = []
    q_waves = []
    r_waves = []
    s_waves = []
    t_waves = []

    for row, peak_list in enumerate(peaks):
        row_p_waves = []
        row_q_waves = []
        row_r_waves = []
        row_s_waves = []
        row_t_waves = []

        if len(peak_list) == 0:
            # Append empty lists if no peaks are detected in this row
            p_waves.append(row_p_waves)
            q_waves.append(row_q_waves)
            r_waves.append(row_r_waves)
            s_waves.append(row_s_waves)
            t_waves.append(row_t_waves)
            continue  # Move to the next row

        r_wave = peak_list[0]  # Initialize with the first peak

        for i in range(1, len(peak_list)):
            if filtered_signal[row][peak_list[i]] > filtered_signal[row][r_wave]:
                r_wave = peak_list[i]

        row_r_waves.append(r_wave)

        q_candidates = [p for p in peak_list if p < r_wave and filtered_signal[row][p] < 0]
        if q_candidates:
            row_q_waves.append(q_candidates[-1])

        s_candidates = [p for p in peak_list if p > r_wave and filtered_signal[row][p] < 0]
        if s_candidates:
            row_s_waves.append(s_candidates[0])

        if row_q_waves:
            p_candidates = [p for p in peak_list if p < row_q_waves[-1]]
            if p_candidates:
                row_p_waves.append(p_candidates[-1])

        if row_s_waves:
            t_candidates = [p for p in peak_list if p > row_s_waves[-1]]
            if t_candidates:
                row_t_waves.append(t_candidates[0])

        # Append detected waves for this row
        p_waves.append(row_p_waves)
        q_waves.append(row_q_waves)
        r_waves.append(row_r_waves)
        s_waves.append(row_s_waves)
        t_waves.append(row_t_waves)

    return p_waves, q_waves, r_waves, s_waves, t_waves




# Iterate over all files in the directory
def PPG_Signals():
    count = 0
    fs = 1000  # Sample rate (Hz)
    # High cut-off frequency (Hz)
    order = 4
    directory = glob("training/training/*.mat")
    for filename in range(len(directory)):
        # Load the .mat file
        threshold = 0.5  # Adjust the threshold as needed
        window_size = 100
        mat_data = scipy.io.loadmat(directory[filename])
        s = mat_data['val']
        lowcut = np.random.uniform(0.1, 1)  # Random lower cutoff frequency between 0.1 and 1 Hz
        highcut = np.random.uniform(2, 10)
        filtered_signal1 = butter_bandpass_filter(s, 0.5, 300.0, fs, order)
        filtered_signal = filtered_signal1[:, :1000]
        # filtered_signal2 = filtered_signal2.flatten()
        diff_signal = differentiate(filtered_signal)

        # Calculate threshold
        threshold = np.mean(diff_signal) * 0.5

        # Find peaks
        peaks = find_peaks(diff_signal, threshold)

        # Mark PQRST waves
        p_waves, q_waves, r_waves, s_waves, t_waves = mark_pqrst(filtered_signal, peaks)

        # Plot the filtered signal with PQRST labels
        # plot_signal_with_pqrst(filtered_signal2, p_waves, q_waves, r_waves, s_waves, t_waves)

        plt.figure(figsize=(12, 6))

        for row in range(filtered_signal.shape[0]):
            if row == 0:
                plt.plot(filtered_signal[row], label='Filtered Signal')
            else:
                plt.plot(filtered_signal[row])

            if p_waves[row]:
                plt.plot(p_waves[row], filtered_signal[row][p_waves[row]], 'go',
                         label='P Waves' if row == 0 else "")
            if q_waves[row]:
                plt.plot(q_waves[row], filtered_signal[row][q_waves[row]], 'bo',
                         label='Q Waves' if row == 0 else "")
            if r_waves[row]:
                plt.plot(r_waves[row], filtered_signal[row][r_waves[row]], 'ro',
                         label='R Waves' if row == 0 else "")
            if s_waves[row]:
                plt.plot(s_waves[row], filtered_signal[row][s_waves[row]], 'mo',
                         label='S Waves' if row == 0 else "")
            if t_waves[row]:
                plt.plot(t_waves[row], filtered_signal[row][t_waves[row]], 'co',
                         label='T Waves' if row == 0 else "")

        plt.xlabel('Time (in Seconds')
        plt.ylabel('Samples')
        plt.legend()
        output_dir = "PQRST Segmented"
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # Save the plot to the directory
        plt.savefig(os.path.join(output_dir, f"_{filename}PQRST_Waves_Segmented.png"))
        # plt.show()
        plt.close()


    return

PPG_Signals()


# #Butrterworth
# import numpy as np
# import matplotlib.pyplot as plt
# from scipy import signal
#
# fs = 1000  # Sampling frequency
# # Generate the time vector properly
# t = np.arange(1000) / fs
# signala = np.sin(2*np.pi*100*t) # with frequency of 100
# plt.plot(t, signala, label='a')
#
# signalb = np.sin(2*np.pi*20*t) # frequency 20
# plt.plot(t, signalb, label='b')
#
# signalc = signala + signalb
# plt.plot(t, signalc, label='c')
#
# fc = 30  # Cut-off frequency of the filter
# w = fc / (fs / 2) # Normalize the frequency
# b, a = signal.butter(5, w, 'low')
# output = signal.filtfilt(b, a, signalc)
# plt.plot(t, output, label='filtered')
# plt.legend()
# plt.show()


# #Butterworth Bandpass filter
#
# import numpy as np
# import matplotlib.pyplot as plt
# from scipy.signal import butter, filtfilt
# def butter_bandpass(lowcut, highcut, fs, order=5):
#    nyq = 0.5 * fs
#    low = lowcut / nyq
#    high = highcut / nyq
#    b, a = butter(order, [low, high], btype='band')
#    return b, a
# def butter_bandpass_filter(data, lowcut, highcut, fs, order=5):
#    b, a = butter_bandpass(lowcut, highcut, fs, order=order)
#    y = filtfilt(b, a, data)
#    return y
# fs = 1000
# t = np.arange(0, 1, 1/fs)
# f1 = 10
# f2 = 50
# sig = np.sin(2*np.pi*f1*t) + np.sin(2*np.pi*f2*t)
# order = 4
# filtered = butter_bandpass_filter(sig, f1, f2, fs, order)
# print("The length of frequencies:",len(filtered))
# print("The Butterworth bandpass filter output of first 50 frequencies:",filtered[:50])
# fig, ax = plt.subplots()
# ax.plot(t, sig, label='Original signal')
# ax.plot(t, filtered, label='Filtered signal')
# ax.set_xlabel('Time [s]')
#
#
#
#
# def mark_pqrst(filtered_signal, pqrst_indices, num_waves=5):
#     peak_labels = ['P', 'Q', 'R', 'S', 'T']
#     labels = []
#     for i in range(min(num_waves, len(pqrst_indices))):
#         labels.append((pqrst_indices[i], peak_labels[i % len(peak_labels)]))
#     return labels
#
#
# def plot_signal_with_pqrst(filtered_signal, labels):
#     plt.plot(filtered_signal.T[:10000])
#     for idx, label in labels:
#         plt.plot(idx, filtered_signal[0][idx], 'x', label=label)
#         plt.text(idx, filtered_signal[0][idx], f' {label}', fontsize=12)
#     plt.xlabel('Time in Seconds')
#     plt.ylabel('Sample Index')
#     plt.legend()
#     plt.show()
